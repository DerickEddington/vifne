#! /usr/bin/env scheme-script

#!r6rs
; Copyright 2012 Derick Eddington.  My MIT-style license is in the file named
; LICENSE from the original collection this file is distributed with.

; This program compiles assembly language of the emulated computer, and stores
; the compiled code in new chunks in an emulator storage file.  It can compile
; either the high-level or the low-level languages.  TODO more.

(import (rnrs base)
        (rnrs control)
        (rnrs lists)
        (rnrs io simple)
        (vifne util assembler)
        (vifne util assembler storage)
        (vifne util startup-tasks)
        (vifne start)
        (vifne config)
        (vifne util command-line))

(define (read-all p)
  (let loop ((a '()))
    (let ((x (read p)))
      (if (eof-object? x)
        (reverse a)
        (loop (cons x a))))))

(define (print n)
  (display "Chunk ID of stored graph:\n")
  (display "#x") (display (number->string n 16)) (newline))


(define-command-line-arguments

  (language-level "-l"
                  (string->symbol) (lambda (s) (memq s '(low high)))
                  'high)

  (storage-file "-f"
                () string-non-empty?
                default-storage-file)

  (initialize-storage-file? "-i"
                            (true-string?) boolean?
                            #F)

  (add-to-startup-tasks? "-a"
                         (true-string?) boolean?
                         #F)

  ; If this is enabled, the assembler allows synthesizing pointers from numbers,
  ; which bypasses capability-security, which sometimes is necessary for
  ; manually constructing a system to run in the emulator.
  (magic? "--magic"
          (true-string?) boolean?
          #F)

  (input rest
         (car open-input-file) values
         (current-input-port)))


(initialize-libraries! storage-file initialize-storage-file?)

(define stored-id
  ; Copy the assembled chunk graph into new chunks in the mmap'ed storage file.
  (store!
   ; Assemble an instruction-segment array-tree, or an arbitrary chunk graph,
   ; represented as Scheme-record chunks.
   (assemble-low (case language-level
                   ((high)
                    (assemble-high (read-all input)))
                   ((low)
                    ; Low-level forms must all be in one datum, to distinguish
                    ; between instruction segment or chunk forms.
                    (read input)))
                 magic?)))

; Print the chunk ID of the new graph in the mmap'ed storage file, so it can be
; used in some other assembly (e.g. via pointer magic).
(print stored-id)

(when add-to-startup-tasks?
  ; Put the new chunk graph in the storage file's startup-tasks stream, so it
  ; will be executed when the emulator is started with the storage file.  Only
  ; sensible for a chunk graph that is an instruction segment.  The -1 argument
  ; causes the reference count to be adjusted to the desired 1, which is
  ; necessary because of the count of 1 that store! gave and the incrementing
  ; that putting in the stream does, i.e. 1 + 1 - 1 = 1.
  (add-startup-task! stored-id -1))
