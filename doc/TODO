Add register-setting instructions/operations that designate the register with a
register group (i.e. any register in the group) and an index in that group.
E.g.: (copy group7 4 r35).  This will allow loops that work on consecutive chunk
fields to use a loop index variable to refer to the registers.  Otherwise such
loops will have to be unrolled so that the required registers can be specified.

Investigate changing all null-pointer tests to check fields' is-pointer flag,
instead of checking for zero value.  Null-pointer will be indicated by not
setting the flag.  This seems cleaner.

Test emulator using multiple processors/processes, by putting multiple
procedures in the startup-tasks-stream.

Need to carefully analyze reference counting to prove it all correct.

It seems possible to create a reference cycle by putting in a stream a chunk
that references one of the stream's handles:
  chunk -> handle -> stream -> elements -> chunk
This could prevent all chunks in the cycle from being freed, even if there are
no outside references to any of them, if the chunk is put in the stream and then
the last outside reference to the stream is cleared.  I think this can't be
prevented.  This is only a problem if it's desired to lose all references to a
stream even if there are elements in it, which seems uncommon, however this is
very reasonable to expect to be able to do.  Not sure what to do about this...

Need to be careful about deadlocking the SMS or a processor because of
message-queue operations blocking.  What if the SMS replies to a processor but
the processor's message queue is full - the SMS will block until the processor
removes a message, unless the MQs are made non-blocking.  But non-blocking MQs
requires buffering unsent messages and coordinating/scheduling retrying to send
unsent messages - very different than real hardware.  Is it possible to make
this dataflow system, via communication with MQs, determinate such that deadlock
is impossible?  I think I'll wait until I have an initial system running, to see
how these issues might happen.

I suspect that the SMS process should have a higher host-OS scheduling priority
than the processor processes, so it can keep up with the amount of requests.

Does an Interprocessor Network need to exist, so the processors can communicate
things such as supplying a join result to an activity on another processor?  If
so, I suppose it should use Posix message queues.

Should chunk access be through the storage controller?  Currently, it's via
direct (foreign) memory access of the mmap'ed file.  Doing it through the
controller is more like the actual FB design, which might be beneficial for
future changes of the emulator.

Explore making "random-access lists", the tree-based list representation of
Okasaki with O(log) random-access and O(1) car, cdr, and cons.  See that SRFI.
Such a representation might work great with chunks, maybe even further optimized
for them, and would provide the basis for implementing Lisp languages.

I think the storage file format currently is endianness-specific and so is not
portable to different endianness machines.  Otherwise, I believe the storage
file format is portable, and sharing storage files seems very desirable, so I
should decide how to make the storage file format portable.
